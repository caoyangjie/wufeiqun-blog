#### 背景介绍

ES的IML生命周期非常好用, 可以灵活配置切割以及删除策略, 这样就不用自己写脚本来删除索引了.

ES的生命周期策略可以在hot阶段配置Rollover自动切割, 切割可以根据索引的大小以及索引创建的时间两个维度, 这个已经可以满足绝大多数的场景了, 如下的配置

<img width="2063" alt="image" src="https://github.com/user-attachments/assets/da9799f4-4232-41b5-9052-ab815ecf9753">

表示主分片的大小超过20G, 或者索引的创建时间超过60天后就会切割, 也就是会产生一个新的索引, 我们这边是配置了6个分片, 也就是每个索引打到6*20=120G的时候会切割, 时间和大小的条件是或的关系, 也就是达到任何一个都会切割.

删除的时候是根据切割后的索引的创建时间来删除的, 目前只能配置时间, 这一点不太爽, 如果能配置个数就很完美了.

不同业务因为产生的日志的数量不同, 但是因为都是采用相同的filebeat, 所以配置了相同的生命周期策略, 这里就要平衡各个业务,以及总的磁盘占用情况.

#### ELK分开存储日志时间方法记录

* Index Lifecycle Policy可以配置归档策略, 比如单一节点上的主分片大小达到xxGB, 或者文档数量, 或者存在的时间等; 达到条件以后, ES就会创建一个新的索引. 同时也可以配置删除策略, 这里有一个细节是删除策略只可以按照已存档的索引的存活时间.
* Index Lifecycle Policy 会绑定到 Index Template
* Index Template可以配置Index Pattern和Priority来确定新创建的Datastream走哪一个Index Template
* DataStream创建的时候会选择一个Index Template, 然后就固定下来了
* 新插入的数据根据上述的一系列规则进行存储/归档/删除等

所以问题就来了, 因为有的日志数量特别大, 有的特别小, 日志保留的时间又各不相同, 保留时间太长会占用巨大的磁盘, 保留时间太短不能满足业务需要, 所以还是需要分开. 需要创建多个Index Lifecycle Policy, 以及多个Index Template,让保留日志长的和短的通过Index Template的Index Pattern策略给区分开.
